ğŸ“š 922. Sort Array By Parity II  
ğŸ”— Link: https://leetcode.com/problems/sort-array-by-parity-ii/description/

ğŸ§  Concept Used: Two Pointers (Index Skipping Strategy)

ğŸ’¡ Problem Statement:  
Given an array `nums` of *even length*, where half the integers are **even** and half are **odd**,  
rearrange it so that **even-indexed positions contain even numbers** and **odd-indexed positions contain odd numbers**.  
Return any valid array that satisfies the condition.

ğŸ” Approach (Two Pointer Skipping Style):
- Use two pointers: 
  - `even` â†’ starts from index `0` and jumps by +2
  - `odd` â†’ starts from index `1` and jumps by +2
- If `nums[even]` is already even, itâ€™s in correct place â†’ move `even` ahead.
- If `nums[odd]` is already odd â†’ move `odd` ahead.
- If both are wrong â†’ swap them!

ğŸ¯ Logic:
- Only swap when one even index has an odd number and one odd index has an even number.
- This guarantees correctness because we know the array has **equal number of evens and odds**.

ğŸ˜… Solved by solution and chatgpt
â±ï¸ Time taken: 35 mins  

ğŸ Mistakes made:
   -frgt even ++ and odd++ in swap

ğŸ§ª Next Goal:
- Try variations: sort vowels/consonants at alternate positions
- Explore DSA pattern "In-place Reordering with Conditions"

ğŸ“ˆ Time Complexity: O(n)  
ğŸ—ƒï¸ Space Complexity: O(1) (in-place)  
âœ… Runtime: 3 ms  
ğŸ“¦ Memory: 47.7 MB

ğŸ“Œ #LeetCode #DSA #TwoPointers #Java #CodingJourney #LearningInPublic #ArrayReordering */

// âœ… Java Code:



class Solution {
    public int[] sortArrayByParityII(int[] nums) {
         int even = 0;
    int odd = 1;

    while (even < nums.length && odd < nums.length) {
        if (nums[even] % 2 == 0) {
            even += 2;
        } else if (nums[odd] % 2 == 1) {
            odd += 2;
        } else {
            // Swap
            int temp = nums[even];
            nums[even] = nums[odd];
            nums[odd] = temp;
            even += 2;
            odd += 2;
        }
    }

    return nums;
        
    }
}
